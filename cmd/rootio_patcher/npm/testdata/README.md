# NPM Parser Test Fixtures

This directory contains test fixtures for testing npm/yarn/pnpm lock file parsing.

## Structure

```
testdata/
├── npm/
│   ├── package.json         # Test project for npm
│   └── package-lock.json    # Generated npm lock file (fixture)
├── yarn/
│   ├── package.json         # Test project for yarn
│   └── yarn.lock            # Generated yarn lock file (fixture)
├── pnpm/
│   ├── package.json         # Test project for pnpm
│   └── pnpm-lock.yaml       # Generated pnpm lock file (fixture)
└── generate_fixtures.sh     # Script to regenerate lock files
```

## Test Dependencies

Each `package.json` includes:
- **Production dependencies**: `lodash@4.17.21`, `express@4.18.2`
- **Dev dependencies**: `jest@29.0.0`

These packages were chosen to:
1. Have stable versions for reproducible tests
2. Include both direct and transitive dependencies
3. Test dev vs production dependency detection
4. Provide a realistic but manageable dependency tree

## Regenerating Fixtures

When you need to update the test fixtures (e.g., to test against newer package versions):

```bash
cd cmd/rootio_patcher/npm/testdata
./generate_fixtures.sh
```

The script will:
1. Clean existing lock files and node_modules
2. Generate fresh lock files using `npm install --package-lock-only`, `yarn install --mode update-lockfile`, and `pnpm install --lockfile-only`
3. Report which package managers are available

**Note**: You need npm/yarn/pnpm installed on your system to generate the respective lock files.

## What Tests Use These Fixtures

The fixture-based tests (`parser_fixtures_test.go`) verify:

1. **Real-world parsing**: Parsing actual lock files generated by package managers
2. **Package extraction**: Finding expected dependencies (lodash, express, jest)
3. **Version detection**: Correct version strings for each package
4. **Dev dependency detection**: Correctly marking dev vs production dependencies
5. **Transitive dependencies**: Parsing nested/transitive dependencies
6. **Structure validation**: All parsed packages have required fields
7. **Update operations**: Modifying versions in lock files

## Why Use Fixtures?

1. **Realistic testing**: Tests use actual lock files generated by package managers
2. **Regression prevention**: Detects parsing issues with real-world data
3. **Version compatibility**: Ensures parser works with current lock file formats
4. **Coverage**: Tests handle complex dependency trees, not just synthetic examples

## Adding New Test Scenarios

To add new test scenarios:

1. Create a new subdirectory (e.g., `testdata/complex/`)
2. Add a `package.json` with your test dependencies
3. Update `generate_fixtures.sh` to generate lock files for the new scenario
4. Add tests in `parser_fixtures_test.go` that use the new fixtures
